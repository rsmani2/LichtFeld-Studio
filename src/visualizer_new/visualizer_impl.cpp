/* SPDX-FileCopyrightText: 2025 LichtFeld Studio Authors
 *
 * SPDX-License-Identifier: GPL-3.0-or-later */

#include "visualizer_impl.hpp"
#include "command/commands/crop_command.hpp"
#include "command/commands/selection_command.hpp"
#include "core/data_loading_service.hpp"
#include "core_new/logger.hpp"
#include "scene/scene_manager.hpp"
#include "tools/align_tool.hpp"
#include "tools/brush_tool.hpp"
#include "tools/selection_tool.hpp"
#include <stdexcept>
#ifdef WIN32
#include <windows.h>
#endif

namespace lfs::vis {

    using namespace lfs::core::events;

    VisualizerImpl::VisualizerImpl(const ViewerOptions& options)
        : options_(options),
          viewport_(options.width, options.height),
          window_manager_(std::make_unique<WindowManager>(options.title, options.width, options.height)) {

        LOG_DEBUG("Creating visualizer with window size {}x{}", options.width, options.height);

        // Create scene manager - it creates its own Scene internally
        scene_manager_ = std::make_unique<SceneManager>();

        // Create trainer manager
        trainer_manager_ = std::make_shared<TrainerManager>();
        trainer_manager_->setViewer(this);
        scene_manager_->setTrainerManager(trainer_manager_.get());

        // Create support components
        gui_manager_ = std::make_unique<gui::GuiManager>(this);

        // Create rendering manager with initial antialiasing setting
        rendering_manager_ = std::make_unique<RenderingManager>();

        // Connect scene manager to rendering manager
        scene_manager_->setRenderingManager(rendering_manager_.get());

        // Set initial antialiasing
        RenderSettings initial_settings;
        initial_settings.antialiasing = options.antialiasing;
        initial_settings.gut = options.gut;
        rendering_manager_->updateSettings(initial_settings);

        // Create data loading service
        data_loader_ = std::make_unique<DataLoadingService>(scene_manager_.get());

        // Create main loop
        main_loop_ = std::make_unique<MainLoop>();

        // Setup connections
        setupEventHandlers();
        setupComponentConnections();
    }

    VisualizerImpl::~VisualizerImpl() {
        trainer_manager_.reset();
        brush_tool_.reset();
        tool_context_.reset();
        if (gui_manager_) {
            gui_manager_->shutdown();
        }
        LOG_DEBUG("Visualizer destroyed");
    }

    void VisualizerImpl::initializeTools() {
        if (tools_initialized_) {
            LOG_TRACE("Tools already initialized, skipping");
            return;
        }

        tool_context_ = std::make_unique<ToolContext>(
            rendering_manager_.get(),
            scene_manager_.get(),
            &viewport_,
            window_manager_->getWindow(),
            &command_history_);

        // Connect tool context to input controller
        if (input_controller_) {
            input_controller_->setToolContext(tool_context_.get());
        }

        brush_tool_ = std::make_shared<tools::BrushTool>();
        if (!brush_tool_->initialize(*tool_context_)) {
            LOG_ERROR("Failed to initialize brush tool");
            brush_tool_.reset();
        } else if (input_controller_) {
            input_controller_->setBrushTool(brush_tool_);
        }

        align_tool_ = std::make_shared<tools::AlignTool>();
        if (!align_tool_->initialize(*tool_context_)) {
            LOG_ERROR("Failed to initialize align tool");
            align_tool_.reset();
        } else if (input_controller_) {
            input_controller_->setAlignTool(align_tool_);
        }

        selection_tool_ = std::make_shared<tools::SelectionTool>();
        if (!selection_tool_->initialize(*tool_context_)) {
            LOG_ERROR("Failed to initialize selection tool");
            selection_tool_.reset();
        } else if (input_controller_) {
            input_controller_->setSelectionTool(selection_tool_);
            // Connect input bindings to selection tool for customizable scroll actions
            selection_tool_->setInputBindings(&input_controller_->getBindings());
        }

        tools_initialized_ = true;
    }

    void VisualizerImpl::setupComponentConnections() {
        // Set up main loop callbacks
        main_loop_->setInitCallback([this]() { return initialize(); });
        main_loop_->setUpdateCallback([this]() { update(); });
        main_loop_->setRenderCallback([this]() { render(); });
        main_loop_->setShutdownCallback([this]() { shutdown(); });
        main_loop_->setShouldCloseCallback([this]() { return allowclose(); });

        // Connect command history to scene manager for undo/redo support
        scene_manager_->setCommandHistory(&command_history_);

        gui_manager_->setFileSelectedCallback([this](const std::filesystem::path& path, bool is_dataset) {
            lfs::core::events::cmd::LoadFile{.path = path, .is_dataset = is_dataset}.emit();
        });
    }

    void VisualizerImpl::setupEventHandlers() {
        using namespace lfs::core::events;

        // Training commands
        cmd::StartTraining::when([this](const auto&) {
            if (trainer_manager_) {
                trainer_manager_->startTraining();
            }
        });

        cmd::PauseTraining::when([this](const auto&) {
            if (trainer_manager_) {
                trainer_manager_->pauseTraining();
            }
        });

        cmd::ResumeTraining::when([this](const auto&) {
            if (trainer_manager_) {
                trainer_manager_->resumeTraining();
            }
        });

        cmd::StopTraining::when([this](const auto&) {
            if (trainer_manager_) {
                trainer_manager_->stopTraining();
            }
        });

        cmd::ResetTraining::when([this](const auto&) {
            if (!scene_manager_ || !scene_manager_->hasDataset()) {
                LOG_WARN("Cannot reset: no dataset loaded");
                return;
            }

            if (trainer_manager_ && trainer_manager_->isTrainingActive()) {
                trainer_manager_->stopTraining();
                trainer_manager_->waitForCompletion();
            }

            const auto& path = scene_manager_->getDatasetPath();
            if (path.empty()) {
                LOG_ERROR("Cannot reset: dataset path is empty");
                return;
            }

            LOG_INFO("Resetting training: {}", path.string());
            if (const auto result = data_loader_->loadDataset(path); !result) {
                LOG_ERROR("Failed to reload dataset: {}", result.error());
            }
        });

        cmd::SaveCheckpoint::when([this](const auto&) {
            if (trainer_manager_) {
                trainer_manager_->requestSaveCheckpoint();
            }
        });

        // Undo/Redo commands
        cmd::Undo::when([this](const auto&) { undo(); });
        cmd::Redo::when([this](const auto&) { redo(); });

        // Selection operations
        cmd::DeleteSelected::when([this](const auto&) { deleteSelectedGaussians(); });
        cmd::InvertSelection::when([this](const auto&) { invertSelection(); });
        cmd::DeselectAll::when([this](const auto&) { deselectAll(); });
        cmd::CopySelection::when([this](const auto&) { copySelection(); });
        cmd::PasteSelection::when([this](const auto&) { pasteSelection(); });

        // Render settings changes
        ui::RenderSettingsChanged::when([this]([[maybe_unused]] const auto& event) {
            if (rendering_manager_) {
                // The rendering manager handles this internally now
                // Just need to mark dirty which happens in its event handler
            }
        });

        // Camera moves - mark dirty
        ui::CameraMove::when([this](const auto&) {
            if (rendering_manager_) {
                rendering_manager_->markDirty();
            }
        });

        // Scene changes - mark dirty
        state::SceneChanged::when([this](const auto&) {
            if (window_manager_) {
                window_manager_->requestRedraw();
            }
            if (rendering_manager_) {
                rendering_manager_->markDirty();
            }
        });

        // Point cloud mode changes - request redraw
        ui::PointCloudModeChanged::when([this](const auto&) {
            if (window_manager_) {
                window_manager_->requestRedraw();
            }
        });

        internal::TrainerReady::when([this](const auto&) {
            internal::TrainingReadyToStart{}.emit();
        });

        // Training progress - don't mark dirty, let throttling handle it
        state::TrainingProgress::when([this]([[maybe_unused]] const auto& event) {
            // Just update loss buffer, don't force render
            // The 1 FPS throttle will handle rendering
        });

        // Listen for file load commands
        cmd::LoadProject::when([this](const auto& cmd) {
            handleLoadProjectCommand(cmd);
        });

        // Listen to TrainingStarted - switch to splat rendering and select training model
        state::TrainingStarted::when([this](const auto&) {
            ui::PointCloudModeChanged{
                .enabled = false,
                .voxel_size = 0.03f}
                .emit();

            // Select the training model so it's visible
            if (scene_manager_) {
                const auto& scene = scene_manager_->getScene();
                const auto& model_name = scene.getTrainingModelNodeName();
                if (!model_name.empty()) {
                    scene_manager_->selectNode(model_name);
                    LOG_INFO("Selected training model '{}' for training", model_name);
                }
            }

            LOG_INFO("Switched to splat rendering mode (training started)");
        });

        // Listen to TrainingCompleted
        state::TrainingCompleted::when([this](const auto& event) {
            handleTrainingCompleted(event);
        });

        // Listen to load dataset (we need to update project)
        cmd::LoadFile::when([this](const auto& cmd) {
            handleLoadFileCommand(cmd);
        });

        // Listen to save project
        cmd::SaveProject::when([this](const auto& cmd) {
            handleSaveProject(cmd);
        });
    }

    bool VisualizerImpl::initialize() {
        // Track if we're fully initialized
        static bool fully_initialized = false;
        if (fully_initialized) {
            LOG_TRACE("Already fully initialized");
            return true;
        }

        // Initialize window first and ensure it has proper size
        if (!window_initialized_) {
            if (!window_manager_->init()) {
                return false;
            }
            window_initialized_ = true;

            // Poll events to get actual window dimensions
            window_manager_->pollEvents();
            window_manager_->updateWindowSize();

            // Update viewport with actual window size
            viewport_.windowSize = window_manager_->getWindowSize();
            viewport_.frameBufferSize = window_manager_->getFramebufferSize();

            // Validate we got reasonable dimensions
            if (viewport_.windowSize.x <= 0 || viewport_.windowSize.y <= 0) {
                LOG_WARN("Window manager returned invalid size, using options fallback: {}x{}",
                         options_.width, options_.height);
                viewport_.windowSize = glm::ivec2(options_.width, options_.height);
                viewport_.frameBufferSize = glm::ivec2(options_.width, options_.height);
            }

            LOG_DEBUG("Window initialized with actual size: {}x{}",
                      viewport_.windowSize.x, viewport_.windowSize.y);
        }

        // Initialize GUI (sets up ImGui callbacks)
        if (!gui_initialized_) {
            gui_manager_->init();
            gui_initialized_ = true;
        }

        // Create simplified input controller AFTER ImGui is initialized
        if (!input_controller_) {
            input_controller_ = std::make_unique<InputController>(
                window_manager_->getWindow(), viewport_);
            input_controller_->initialize();
            input_controller_->setTrainingManager(trainer_manager_);
            input_controller_->setRenderingManager(rendering_manager_.get());
            input_controller_->setGuiManager(gui_manager_.get());
        }

        // Initialize rendering with proper viewport dimensions
        if (!rendering_manager_->isInitialized()) {
            // Pass viewport dimensions to rendering manager
            rendering_manager_->setInitialViewportSize(viewport_.windowSize);
            rendering_manager_->initialize();
        }

        // Initialize tools AFTER rendering is initialized (only once!)
        if (!tools_initialized_) {
            initializeTools();
        }

        fully_initialized = true;
        return true;
    }

    void VisualizerImpl::update() {
        window_manager_->updateWindowSize();

        // Update the main viewport with window size
        viewport_.windowSize = window_manager_->getWindowSize();
        viewport_.frameBufferSize = window_manager_->getFramebufferSize();

        if (brush_tool_ && brush_tool_->isEnabled() && tool_context_) {
            brush_tool_->update(*tool_context_);
        }
        if (selection_tool_ && selection_tool_->isEnabled() && tool_context_) {
            selection_tool_->update(*tool_context_);
        }
    }

    void VisualizerImpl::render() {
        // Calculate delta time for input updates
        static auto last_frame_time = std::chrono::high_resolution_clock::now();
        auto now = std::chrono::high_resolution_clock::now();
        float delta_time = std::chrono::duration<float>(now - last_frame_time).count();
        last_frame_time = now;

        // Clamp delta time to prevent huge jumps (min 30 FPS)
        delta_time = std::min(delta_time, 1.0f / 30.0f);

        // Update input controller with viewport bounds
        if (gui_manager_) {
            auto pos = gui_manager_->getViewportPos();
            auto size = gui_manager_->getViewportSize();
            input_controller_->updateViewportBounds(pos.x, pos.y, size.x, size.y);
            if (tool_context_) {
                tool_context_->updateViewportBounds(pos.x, pos.y, size.x, size.y);
            }
        }

        // Update point cloud mode in input controller
        auto* rendering_manager = getRenderingManager();
        if (rendering_manager) {
            const auto& settings = rendering_manager->getSettings();
            input_controller_->setPointCloudMode(settings.point_cloud_mode);
        }

        if (input_controller_) {
            input_controller_->update(delta_time);
        }

        // Get viewport region from GUI
        ViewportRegion viewport_region;
        bool has_viewport_region = false;
        if (gui_manager_) {
            ImVec2 pos = gui_manager_->getViewportPos();
            ImVec2 size = gui_manager_->getViewportSize();

            viewport_region.x = pos.x;
            viewport_region.y = pos.y;
            viewport_region.width = size.x;
            viewport_region.height = size.y;

            has_viewport_region = true;
        }

        // viewport_region accounts for toolbar offset - required for all render modes
        RenderingManager::RenderContext context{
            .viewport = viewport_,
            .settings = rendering_manager_->getSettings(),
            .viewport_region = has_viewport_region ? &viewport_region : nullptr,
            .has_focus = gui_manager_ && gui_manager_->isViewportFocused(),
            .scene_manager = scene_manager_.get()};

        rendering_manager_->renderFrame(context, scene_manager_.get());

        gui_manager_->render();

        window_manager_->swapBuffers();

        // Render-on-demand: VSync handles frame pacing, waitEvents saves CPU when idle
        const bool is_training = trainer_manager_ && trainer_manager_->isRunning();
        const bool needs_render = rendering_manager_->needsRender();
        const bool continuous_input = input_controller_ && input_controller_->isContinuousInputActive();

        if (needs_render || continuous_input) {
            // Dirty or active input (WASD/orbit/pan): poll for smooth interaction
            window_manager_->pollEvents();
        } else if (is_training) {
            // Training: short wait for UI responsiveness
            constexpr double TRAINING_WAIT_SEC = 0.016;  // ~60 Hz
            window_manager_->waitEvents(TRAINING_WAIT_SEC);
        } else {
            // Idle: long wait to minimize CPU usage (VSync still applies on wake)
            constexpr double IDLE_WAIT_SEC = 0.5;
            window_manager_->waitEvents(IDLE_WAIT_SEC);
        }
    }

    bool VisualizerImpl::allowclose() {
        // If we are trying to close and the project is temporary, show dialog
        if (window_manager_->shouldClose() && !gui_manager_->isForceExit()) {
            if (project_) {
                if (project_->getIsTempProject() && !project_->getIsProjectEmpty()) {
                    gui_manager_->showWindow("project_changed_dialog_box", true);
                    window_manager_->cancelClose();
                }
            }
        }
        // If we are trying to close and the project is temporary and we are forcing exit, unlock project
        if (window_manager_->shouldClose() && gui_manager_->isForceExit()) {
            if (project_) {
                if (project_->getIsTempProject()) {
                    project_->unlockProject();
                }
            }
        }

#ifdef WIN32
        // show console in case it was hidden to prevent cmd window to stay hidden/in memory after closing the application
        if (window_manager_->shouldClose()) {
            HWND hwnd = GetConsoleWindow();
            Sleep(1);
            HWND owner = GetWindow(hwnd, GW_OWNER);
            DWORD dwProcessId;
            GetWindowThreadProcessId(hwnd, &dwProcessId);

            // show console if we started from console
            if (GetCurrentProcessId() != dwProcessId) {
                if (owner == NULL) {
                    ShowWindow(hwnd, SW_SHOW); // Windows 10
                } else {
                    ShowWindow(owner, SW_SHOW); // Windows 11
                }
            }
        }
#endif

        return window_manager_->shouldClose();
    }

    void VisualizerImpl::shutdown() {
        // Stop training before GPU resources are freed
        if (trainer_manager_) {
            if (trainer_manager_->isTrainingActive()) {
                trainer_manager_->stopTraining();
                trainer_manager_->waitForCompletion();
            }
            trainer_manager_.reset();
        }

        // Shutdown tools
        if (brush_tool_) {
            brush_tool_->shutdown();
            brush_tool_.reset();
        }
        if (selection_tool_) {
            selection_tool_->shutdown();
            selection_tool_.reset();
        }

        // Clean up tool context
        tool_context_.reset();

        command_history_.clear();

        tools_initialized_ = false;
    }

    void VisualizerImpl::undo() {
        command_history_.undo();
        if (rendering_manager_) {
            rendering_manager_->markDirty();
        }
    }

    void VisualizerImpl::redo() {
        command_history_.redo();
        if (rendering_manager_) {
            rendering_manager_->markDirty();
        }
    }

    void VisualizerImpl::deleteSelectedGaussians() {
        if (!scene_manager_) return;

        auto& scene = scene_manager_->getScene();
        auto selection = scene.getSelectionMask();

        if (!selection || !selection->is_valid()) {
            LOG_INFO("No Gaussians selected to delete");
            return;
        }

        // Get all visible nodes and apply deletion
        auto nodes = scene.getVisibleNodes();
        if (nodes.empty()) return;

        size_t offset = 0;
        bool any_deleted = false;

        for (const auto* node : nodes) {
            if (!node || !node->model) continue;

            const size_t node_size = node->model->size();
            if (node_size == 0) continue;

            // Extract selection for this node
            auto node_selection = selection->slice(0, offset, offset + node_size);

            // Convert selection (uint8) to bool tensor for soft_delete
            auto bool_mask = node_selection.to(lfs::core::DataType::Bool);

            // Get old state for undo (clone before modifying)
            auto old_deleted = node->model->has_deleted_mask()
                ? node->model->deleted().clone()
                : lfs::core::Tensor::zeros({node_size}, lfs::core::Device::CUDA, lfs::core::DataType::Bool);

            // Apply soft delete (OR with existing deleted mask)
            node->model->soft_delete(bool_mask);

            // Get new state for redo
            auto new_deleted = node->model->deleted().clone();

            // Create undo command
            auto cmd = std::make_unique<command::CropCommand>(
                scene_manager_.get(), node->name, std::move(old_deleted), std::move(new_deleted));
            command_history_.execute(std::move(cmd));

            any_deleted = true;
            offset += node_size;
        }

        if (any_deleted) {
            LOG_INFO("Deleted selected Gaussians");
            // Mark scene as dirty to rebuild combined model with updated deletion masks
            scene.markDirty();
            // Clear selection after deletion
            scene.clearSelection();
            if (rendering_manager_) {
                rendering_manager_->markDirty();
            }
        }
    }

    void VisualizerImpl::invertSelection() {
        if (!scene_manager_) return;
        auto& scene = scene_manager_->getScene();
        const size_t total = scene.getTotalGaussianCount();
        if (total == 0) return;

        const auto old_mask = scene.getSelectionMask();
        const auto ones = lfs::core::Tensor::ones({total}, lfs::core::Device::CUDA, lfs::core::DataType::UInt8);
        auto new_mask = std::make_shared<lfs::core::Tensor>(
            (old_mask && old_mask->is_valid()) ? ones - *old_mask : ones);

        scene.setSelectionMask(new_mask);
        command_history_.execute(std::make_unique<command::SelectionCommand>(
            scene_manager_.get(),
            old_mask ? std::make_shared<lfs::core::Tensor>(old_mask->clone()) : nullptr,
            new_mask));
        if (rendering_manager_) rendering_manager_->markDirty();
    }

    void VisualizerImpl::deselectAll() {
        if (selection_tool_) selection_tool_->clearPolygon();

        if (!scene_manager_) return;
        auto& scene = scene_manager_->getScene();
        if (!scene.hasSelection()) return;

        const auto old_mask = scene.getSelectionMask();
        scene.clearSelection();
        command_history_.execute(std::make_unique<command::SelectionCommand>(
            scene_manager_.get(),
            old_mask ? std::make_shared<lfs::core::Tensor>(old_mask->clone()) : nullptr,
            nullptr));
        if (rendering_manager_) rendering_manager_->markDirty();
    }

    void VisualizerImpl::copySelection() {
        if (!scene_manager_) return;
        scene_manager_->copySelection();
    }

    void VisualizerImpl::pasteSelection() {
        if (!scene_manager_) return;

        const auto pasted_names = scene_manager_->pasteSelection();
        if (pasted_names.empty()) return;

        if (selection_tool_) {
            selection_tool_->clearPolygon();
            selection_tool_->setEnabled(false);
        }
        scene_manager_->getScene().resetSelectionState();

        // Select all pasted nodes
        scene_manager_->clearSelection();
        for (const auto& name : pasted_names) {
            scene_manager_->addToSelection(name);
        }

        if (rendering_manager_) rendering_manager_->markDirty();
    }

    bool VisualizerImpl::LoadProject() {
        if (project_) {
            try {
                LOG_TIMER("LoadProject");
                // write to project file on every change - maybe configurable in the future?
                project_->setUpdateFileOnChange(true);

                // Load dataset from project if available and not already loaded
                auto dataset = static_cast<const lfs::core::param::DatasetConfig&>(project_->getProjectData().data_set_info);
                if (!dataset.data_path.empty() && !scene_manager_->hasDataset()) {
                    LOG_DEBUG("Loading dataset from project: {}", dataset.data_path.string());
                    auto result = data_loader_->loadDataset(dataset.data_path);
                    if (!result) {
                        LOG_ERROR("Failed to load dataset from project: {}", result.error());
                        throw std::runtime_error(std::format("Failed to load dataset from project: {}", result.error()));
                    }
                } else if (scene_manager_->hasDataset()) {
                    LOG_DEBUG("Dataset already loaded, skipping project load");
                }
                // update the project of all the different managers
                updateProjectOnModules();
                // load plys
                LoadProjectPlys();

                auto plys = project_->getPlys();
                LOG_INFO("Project loaded successfully with {} PLY files", plys.size());
            } catch (const std::exception& e) {
                LOG_ERROR("Failed to load project: {}", e.what());
                throw std::runtime_error(std::format("Failed to load project: {}", e.what()));
            }

            return true;
        }
        return false;
    }

    void VisualizerImpl::LoadProjectPlys() {
        if (!project_) {
            LOG_ERROR("LoadProjectPlys: project is not initialized");
            return;
        }

        auto plys = project_->getPlys();
        LOG_DEBUG("Loading {} PLY files from project", plys.size());

        // sort according to iter numbers
        std::sort(plys.begin(), plys.end(),
                  [](const lfs::project::PlyData& a, const lfs::project::PlyData& b) {
                      return a.ply_training_iter_number < b.ply_training_iter_number;
                  });

        if (!plys.empty()) {
            scene_manager_->changeContentType(SceneManager::ContentType::SplatFiles);
        }

        // set all of the nodes to invisible except the last one
        for (auto it = plys.begin(); it != plys.end(); ++it) {
            std::string ply_name = it->ply_name;
            if (!std::filesystem::exists(it->ply_path)) {
                LOG_ERROR("ply path not exists {}. skip loading", it->ply_path.string());
                continue;
            }
            bool is_last = (std::next(it) == plys.end());

            LOG_TRACE("Adding PLY '{}' to scene (visible: {})", ply_name, is_last);
            try {
                scene_manager_->addSplatFile(it->ply_path, ply_name, is_last);
                scene_manager_->setPLYVisibility(ply_name, is_last);
            } catch (const std::exception& e) {
                LOG_ERROR("failed loading ply path {}. reason {} ", it->ply_path.string(), e.what());
            }
        }
    }

    void VisualizerImpl::run() {
        // The main loop will call initialize() as its init callback
        // Don't duplicate initialization here
        LoadProject();
        main_loop_->run();
    }

    void VisualizerImpl::setParameters(const lfs::core::param::TrainingParameters& params) {
        data_loader_->setParameters(params);
    }

    std::expected<void, std::string> VisualizerImpl::loadPLY(const std::filesystem::path& path) {
        LOG_TIMER("LoadPLY");

        // Ensure full initialization before loading PLY
        // This will only initialize once due to the guard in initialize()
        if (!initialize()) {
            return std::unexpected("Failed to initialize visualizer");
        }

        LOG_INFO("Loading PLY file: {}", path.string());
        return data_loader_->loadPLY(path);
    }

    std::expected<void, std::string> VisualizerImpl::loadDataset(const std::filesystem::path& path) {
        LOG_TIMER("LoadDataset");

        // Ensure full initialization before loading dataset
        // This will only initialize once due to the guard in initialize()
        if (!initialize()) {
            return std::unexpected("Failed to initialize visualizer");
        }

        LOG_INFO("Loading dataset: {}", path.string());
        auto result = data_loader_->loadDataset(path);
        if (result && project_) {
            auto data_config = project_->getProjectData().data_set_info;
            if (data_config.data_path.empty() || data_config.data_path == path) { // empty project or same data
                data_config.data_path = path;
                project_->setDataInfo(data_config);
            } else {
                project_ = lfs::project::CreateTempNewProject(data_config, project_->getOptimizationParams());
                updateProjectOnModules();
            }
        }

        return result;
    }

    void VisualizerImpl::clearScene() {
        data_loader_->clearScene();
    }

    bool VisualizerImpl::openProject(const std::filesystem::path& path) {
        LOG_TIMER("OpenProject");

        auto project = std::make_shared<lfs::project::Project>();

        if (!project) {
            LOG_ERROR("Failed to create project object");
            throw std::runtime_error("Failed to create project object");
        }

        if (!project->readFromFile(path)) {
            LOG_ERROR("Failed to read project file: {}", path.string());
            throw std::runtime_error(std::format("Failed to read project file: {}", path.string()));
        }

        if (!project->validateProjectData()) {
            LOG_ERROR("Failed to validate project data from: {}", path.string());
            throw std::runtime_error(std::format("Failed to validate project data from: {}", path.string()));
        }

        project_ = project;
        LOG_INFO("Project opened successfully: {}", path.string());

        return true;
    }

    bool VisualizerImpl::closeProject(const std::filesystem::path& path) {
        if (!project_) {
            LOG_WARN("No project to close");
            return false;
        }

        if (!path.empty()) {
            project_->setProjectFileName(path);
        }

        bool success = project_->writeToFile();
        if (success) {
            LOG_INFO("Project saved successfully");
        } else {
            LOG_ERROR("Failed to save project");
        }

        return success;
    }

    void VisualizerImpl::attachProject(std::shared_ptr<lfs::project::Project> _project) {
        project_ = _project;
        updateProjectOnModules();
    }

    std::shared_ptr<lfs::project::Project> VisualizerImpl::getProject() {
        return project_;
    }

    void VisualizerImpl::handleLoadProjectCommand(const lfs::core::events::cmd::LoadProject& cmd) {
        try {
            bool success = openProject(cmd.path);
            if (!success) {
                throw std::runtime_error(std::format("Failed opening project: {}", cmd.path.string()));
            }

            success = LoadProject();
            if (!success) {
                throw std::runtime_error(std::format("Failed to load project content: {}", cmd.path.string()));
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Error handling LoadProject command: {}", e.what());

            // Re-throw to let higher level handle it
            throw;
        }
    }

    void VisualizerImpl::handleLoadFileCommand(const lfs::core::events::cmd::LoadFile& cmd) {
        if (cmd.is_dataset && project_) {
            auto data_config = project_->getProjectData().data_set_info;
            data_config.data_path = cmd.path;

            if (project_->getIsTempProject()) {
                data_config.output_path.clear();
                project_ = lfs::project::CreateTempNewProject(data_config, project_->getOptimizationParams());
            } else { // else: project already exits (with output dir) - only need to replace data path
                project_->setDataInfo(data_config);
            }

            updateProjectOnModules();
        }
    }

    void VisualizerImpl::handleSaveProject(const lfs::core::events::cmd::SaveProject& cmd) {
        if (project_) {
            const auto& dst_dir = cmd.project_dir;
            if (!std::filesystem::exists(dst_dir)) {
                bool success = std::filesystem::create_directories(dst_dir);
                if (!success) {
                    LOG_ERROR("Directory creation failed {}", dst_dir.string());
                    return;
                }
                LOG_INFO("created directory successfully {}", dst_dir.string());
            }
            if (project_->getIsTempProject()) {
                if (!project_->portProjectToDir(dst_dir)) {
                    LOG_ERROR("porting project failed. Dst dir {} ", project_->getProjectOutputFolder().string());
                }
                project_->setIsTempProject(false);

                for (const auto& ply : project_->getPlys()) {
                    scene_manager_->updatePlyPath(ply.ply_name, ply.ply_path);
                }

            } else {
                if (!project_->writeToFile()) {
                    LOG_ERROR("save project failed {} ", project_->getProjectFileName().string());
                }
            }
            LOG_INFO("Project was saved successfully to {}", project_->getProjectFileName().string());
        }
    }

    void VisualizerImpl::handleTrainingCompleted([[maybe_unused]] const state::TrainingCompleted& event) {

        if (!scene_manager_) {
            LOG_ERROR("scene manager is not initialized");
            return;
        }
        if (!project_) {
            LOG_ERROR("project is not initialized");
            return;
        }
        // load plys
        LoadProjectPlys();

        if (scene_manager_) {
            scene_manager_->changeContentType(SceneManager::ContentType::Dataset);
        }
    }

    void VisualizerImpl::updateProjectOnModules() {
        if (trainer_manager_) {
            trainer_manager_->setProject(project_);
        }
        if (scene_manager_) {
            scene_manager_->setProject(project_);
        }
    }
} // namespace lfs::vis