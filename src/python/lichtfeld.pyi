"""LichtFeld Python API type stubs for Gaussian splatting control."""

from typing import Callable, Optional, Sequence, Tuple, List, Any, Dict, Union
from enum import Enum

__version__: str
__all__: Tuple[str, ...]


# Hook enum
class Hook(Enum):
    training_start: int
    iteration_start: int
    pre_optimizer_step: int
    post_step: int
    training_end: int


# Tensor class
class Tensor:
    @property
    def shape(self) -> Tuple[int, ...]: ...
    @property
    def ndim(self) -> int: ...
    @property
    def numel(self) -> int: ...
    @property
    def device(self) -> str: ...
    @property
    def dtype(self) -> str: ...
    @property
    def is_contiguous(self) -> bool: ...
    @property
    def is_cuda(self) -> bool: ...

    def size(self, dim: int) -> int: ...
    def clone(self) -> "Tensor": ...
    def cpu(self) -> "Tensor": ...
    def cuda(self) -> "Tensor": ...
    def contiguous(self) -> "Tensor": ...
    def sync(self) -> None: ...

    def item(self) -> float: ...
    def float_(self) -> float: ...
    def int_(self) -> int: ...
    def bool_(self) -> bool: ...

    def numpy(self, copy: bool = True) -> Any: ...

    @staticmethod
    def from_numpy(arr: Any, copy: bool = True) -> "Tensor": ...

    def __getitem__(self, key: Any) -> "Tensor": ...
    def __setitem__(self, key: Any, value: Any) -> None: ...

    def __add__(self, other: Union["Tensor", float]) -> "Tensor": ...
    def __radd__(self, other: float) -> "Tensor": ...
    def __iadd__(self, other: Union["Tensor", float]) -> "Tensor": ...
    def __sub__(self, other: Union["Tensor", float]) -> "Tensor": ...
    def __rsub__(self, other: float) -> "Tensor": ...
    def __isub__(self, other: Union["Tensor", float]) -> "Tensor": ...
    def __mul__(self, other: Union["Tensor", float]) -> "Tensor": ...
    def __rmul__(self, other: float) -> "Tensor": ...
    def __imul__(self, other: Union["Tensor", float]) -> "Tensor": ...
    def __truediv__(self, other: Union["Tensor", float]) -> "Tensor": ...
    def __rtruediv__(self, other: float) -> "Tensor": ...
    def __itruediv__(self, other: Union["Tensor", float]) -> "Tensor": ...
    def __neg__(self) -> "Tensor": ...
    def __abs__(self) -> "Tensor": ...

    def sigmoid(self) -> "Tensor": ...
    def exp(self) -> "Tensor": ...
    def log(self) -> "Tensor": ...
    def sqrt(self) -> "Tensor": ...
    def relu(self) -> "Tensor": ...

    def __eq__(self, other: Union["Tensor", float]) -> "Tensor": ...  # type: ignore
    def __ne__(self, other: Union["Tensor", float]) -> "Tensor": ...  # type: ignore
    def __lt__(self, other: Union["Tensor", float]) -> "Tensor": ...
    def __le__(self, other: Union["Tensor", float]) -> "Tensor": ...
    def __gt__(self, other: Union["Tensor", float]) -> "Tensor": ...
    def __ge__(self, other: Union["Tensor", float]) -> "Tensor": ...
    def __and__(self, other: "Tensor") -> "Tensor": ...
    def __or__(self, other: "Tensor") -> "Tensor": ...
    def __invert__(self) -> "Tensor": ...

    def sum(self, dim: Optional[int] = None, keepdim: bool = False) -> "Tensor": ...
    def mean(self, dim: Optional[int] = None, keepdim: bool = False) -> "Tensor": ...
    def max(self, dim: Optional[int] = None, keepdim: bool = False) -> "Tensor": ...
    def min(self, dim: Optional[int] = None, keepdim: bool = False) -> "Tensor": ...
    def sum_scalar(self) -> float: ...
    def mean_scalar(self) -> float: ...
    def max_scalar(self) -> float: ...
    def min_scalar(self) -> float: ...

    def reshape(self, shape: Sequence[int]) -> "Tensor": ...
    def view(self, shape: Sequence[int]) -> "Tensor": ...
    def squeeze(self, dim: Optional[int] = None) -> "Tensor": ...
    def unsqueeze(self, dim: int) -> "Tensor": ...
    def transpose(self, dim0: int, dim1: int) -> "Tensor": ...
    def permute(self, dims: Sequence[int]) -> "Tensor": ...
    def flatten(self, start_dim: int = 0, end_dim: int = -1) -> "Tensor": ...

    def __repr__(self) -> str: ...
    def __array__(self, dtype: Any = None) -> Any:
        """Return numpy array view (zero-copy for CPU contiguous tensors)."""
        ...


# Context view (caches snapshot on creation)
class Context:
    @property
    def iteration(self) -> int: ...
    @property
    def max_iterations(self) -> int: ...
    @property
    def loss(self) -> float: ...
    @property
    def num_gaussians(self) -> int: ...
    @property
    def is_refining(self) -> bool: ...
    @property
    def is_training(self) -> bool: ...
    @property
    def is_paused(self) -> bool: ...
    @property
    def phase(self) -> str: ...
    @property
    def strategy(self) -> str: ...
    def refresh(self) -> None:
        """Update cached snapshot from current state."""
        ...


# Gaussians view
class Gaussians:
    @property
    def count(self) -> int: ...
    @property
    def sh_degree(self) -> int: ...
    @property
    def max_sh_degree(self) -> int: ...


# Optimizer view
class Optimizer:
    def scale_lr(self, factor: float) -> None: ...
    def set_lr(self, value: float) -> None: ...
    def get_lr(self) -> float: ...


# Model view
class Model:
    def clamp(self, attr: str, min: Optional[float] = None, max: Optional[float] = None) -> None: ...
    def scale(self, attr: str, factor: float) -> None: ...
    def set(self, attr: str, value: float) -> None: ...


# Session
class Session:
    def optimizer(self) -> Optimizer: ...
    def model(self) -> Model: ...
    def pause(self) -> None: ...
    def resume(self) -> None: ...
    def request_stop(self) -> None: ...


# Scene module types
class scene:
    class NodeType(Enum):
        SPLAT: int
        POINTCLOUD: int
        GROUP: int
        CROPBOX: int
        DATASET: int
        CAMERA_GROUP: int
        CAMERA: int
        IMAGE_GROUP: int
        IMAGE: int

    class SelectionGroup:
        @property
        def id(self) -> int: ...
        @property
        def name(self) -> str: ...
        @property
        def color(self) -> Tuple[float, float, float]: ...
        @property
        def count(self) -> int: ...
        @property
        def locked(self) -> bool: ...

    class CropBox:
        @property
        def min(self) -> Tuple[float, float, float]: ...
        @min.setter
        def min(self, value: Tuple[float, float, float]) -> None: ...
        @property
        def max(self) -> Tuple[float, float, float]: ...
        @max.setter
        def max(self, value: Tuple[float, float, float]) -> None: ...
        @property
        def inverse(self) -> bool: ...
        @inverse.setter
        def inverse(self, value: bool) -> None: ...
        @property
        def enabled(self) -> bool: ...
        @enabled.setter
        def enabled(self, value: bool) -> None: ...
        @property
        def color(self) -> Tuple[float, float, float]: ...
        @color.setter
        def color(self, value: Tuple[float, float, float]) -> None: ...
        @property
        def line_width(self) -> float: ...
        @line_width.setter
        def line_width(self, value: float) -> None: ...

    class PointCloud:
        @property
        def means(self) -> Tensor: ...
        @property
        def colors(self) -> Tensor: ...
        @property
        def normals(self) -> Optional[Tensor]: ...
        @property
        def sh0(self) -> Optional[Tensor]: ...
        @property
        def shN(self) -> Optional[Tensor]: ...
        @property
        def opacity(self) -> Optional[Tensor]: ...
        @property
        def scaling(self) -> Optional[Tensor]: ...
        @property
        def rotation(self) -> Optional[Tensor]: ...
        @property
        def size(self) -> int: ...
        @property
        def attribute_names(self) -> List[str]: ...
        def is_gaussian(self) -> bool: ...
        def normalize_colors(self) -> None: ...

    class SplatData:
        def means_raw(self) -> Tensor: ...
        def sh0_raw(self) -> Tensor: ...
        def shN_raw(self) -> Tensor: ...
        def scaling_raw(self) -> Tensor: ...
        def rotation_raw(self) -> Tensor: ...
        def opacity_raw(self) -> Tensor: ...
        def get_means(self) -> Tensor: ...
        def get_opacity(self) -> Tensor: ...
        def get_rotation(self) -> Tensor: ...
        def get_scaling(self) -> Tensor: ...
        def get_shs(self) -> Tensor: ...
        @property
        def active_sh_degree(self) -> int: ...
        @property
        def max_sh_degree(self) -> int: ...
        @property
        def scene_scale(self) -> float: ...
        @property
        def num_points(self) -> int: ...
        def deleted(self) -> Tensor: ...
        def has_deleted_mask(self) -> bool: ...
        def visible_count(self) -> int: ...
        def soft_delete(self, mask: Tensor) -> Tensor: ...
        def undelete(self, mask: Tensor) -> None: ...
        def clear_deleted(self) -> None: ...
        def apply_deleted(self) -> int: ...
        def increment_sh_degree(self) -> None: ...
        def set_active_sh_degree(self, degree: int) -> None: ...
        def set_max_sh_degree(self, degree: int) -> None: ...
        def reserve_capacity(self, capacity: int) -> None: ...

    class SceneNode:
        @property
        def id(self) -> int: ...
        @property
        def parent_id(self) -> int: ...
        @property
        def children(self) -> List[int]: ...
        @property
        def type(self) -> "scene.NodeType": ...
        @property
        def name(self) -> str: ...
        @property
        def local_transform(self) -> Tuple[Tuple[float, ...], ...]: ...
        def set_local_transform(self, transform: Any) -> None: ...
        @property
        def world_transform(self) -> Tuple[Tuple[float, ...], ...]: ...
        @property
        def visible(self) -> bool: ...
        @visible.setter
        def visible(self, value: bool) -> None: ...
        @property
        def locked(self) -> bool: ...
        @locked.setter
        def locked(self, value: bool) -> None: ...
        @property
        def gaussian_count(self) -> int: ...
        @property
        def centroid(self) -> Tuple[float, float, float]: ...
        def splat_data(self) -> Optional["scene.SplatData"]: ...
        def point_cloud(self) -> Optional["scene.PointCloud"]: ...
        def cropbox(self) -> Optional["scene.CropBox"]: ...
        @property
        def camera_index(self) -> int: ...
        @property
        def camera_uid(self) -> int: ...
        @property
        def image_path(self) -> str: ...
        @property
        def mask_path(self) -> str: ...

    class Scene:
        def add_group(self, name: str, parent: int = -1) -> int: ...
        def remove_node(self, name: str, keep_children: bool = False) -> None: ...
        def rename_node(self, old_name: str, new_name: str) -> bool: ...
        def clear(self) -> None: ...
        def reparent(self, node_id: int, new_parent_id: int) -> None: ...
        def root_nodes(self) -> List[int]: ...
        def get_node_by_id(self, id: int) -> Optional["scene.SceneNode"]: ...
        def get_node(self, name: str) -> Optional["scene.SceneNode"]: ...
        def get_nodes(self) -> List["scene.SceneNode"]: ...
        def get_visible_nodes(self) -> List["scene.SceneNode"]: ...
        def is_node_effectively_visible(self, id: int) -> bool: ...
        def get_world_transform(self, node_id: int) -> Tuple[Tuple[float, ...], ...]: ...
        def set_node_transform(self, name: str, transform: Any) -> None: ...
        def combined_model(self) -> Optional["scene.SplatData"]: ...
        def training_model(self) -> Optional["scene.SplatData"]: ...
        def set_training_model_node(self, name: str) -> None: ...
        @property
        def training_model_node_name(self) -> str: ...
        def get_node_bounds(self, id: int) -> Optional[Tuple[Tuple[float, float, float], Tuple[float, float, float]]]: ...
        def get_node_bounds_center(self, id: int) -> Tuple[float, float, float]: ...
        def get_cropbox_for_splat(self, splat_id: int) -> int: ...
        def get_or_create_cropbox_for_splat(self, splat_id: int) -> int: ...
        def get_cropbox_data(self, cropbox_id: int) -> Optional["scene.CropBox"]: ...
        def set_cropbox_data(self, cropbox_id: int, data: "scene.CropBox") -> None: ...
        @property
        def selection_mask(self) -> Optional[Tensor]: ...
        def set_selection(self, indices: Sequence[int]) -> None: ...
        def set_selection_mask(self, mask: Tensor) -> None: ...
        def clear_selection(self) -> None: ...
        def has_selection(self) -> bool: ...
        def add_selection_group(self, name: str, color: Tuple[float, float, float]) -> int: ...
        def remove_selection_group(self, id: int) -> None: ...
        def rename_selection_group(self, id: int, name: str) -> None: ...
        def set_selection_group_color(self, id: int, color: Tuple[float, float, float]) -> None: ...
        def set_selection_group_locked(self, id: int, locked: bool) -> None: ...
        def is_selection_group_locked(self, id: int) -> bool: ...
        @property
        def active_selection_group(self) -> int: ...
        @active_selection_group.setter
        def active_selection_group(self, id: int) -> None: ...
        def selection_groups(self) -> List["scene.SelectionGroup"]: ...
        def update_selection_group_counts(self) -> None: ...
        def clear_selection_group(self, id: int) -> None: ...
        def reset_selection_state(self) -> None: ...
        def has_training_data(self) -> bool: ...
        @property
        def scene_center(self) -> Tensor: ...
        @property
        def node_count(self) -> int: ...
        @property
        def total_gaussian_count(self) -> int: ...
        def has_nodes(self) -> bool: ...
        def apply_deleted(self) -> int: ...
        def invalidate_cache(self) -> None: ...
        def duplicate_node(self, name: str) -> str: ...
        def merge_group(self, group_name: str) -> str: ...


# Camera types
class Camera:
    def focal_x(self) -> float: ...
    def focal_y(self) -> float: ...
    def center_x(self) -> float: ...
    def center_y(self) -> float: ...
    def fov_x(self) -> float: ...
    def fov_y(self) -> float: ...
    def image_width(self) -> int: ...
    def image_height(self) -> int: ...
    def camera_width(self) -> int: ...
    def camera_height(self) -> int: ...
    def image_name(self) -> str: ...
    def image_path(self) -> str: ...
    def mask_path(self) -> str: ...
    def has_mask(self) -> bool: ...
    def uid(self) -> int: ...
    def R(self) -> Tensor: ...
    def T(self) -> Tensor: ...
    def K(self) -> Tensor: ...
    def world_view_transform(self) -> Tensor: ...
    def cam_position(self) -> Tensor: ...
    def load_image(self, resize_factor: int = 1, max_width: int = 3840) -> Tensor: ...
    def load_mask(self, resize_factor: int = 1, max_width: int = 3840, invert: bool = False, threshold: float = 0.5) -> Tensor: ...


class CameraDataset:
    def size(self) -> int: ...
    def __len__(self) -> int: ...
    def get(self, index: int) -> Camera: ...
    def __getitem__(self, index: int) -> Camera: ...
    def get_camera_by_filename(self, filename: str) -> Optional[Camera]: ...
    def cameras(self) -> List[Camera]: ...
    def set_resize_factor(self, factor: int) -> None: ...
    def set_max_width(self, width: int) -> None: ...


# Top-level functions
def context() -> Context: ...
def gaussians() -> Gaussians: ...
def session() -> Session: ...
def get_scene() -> Optional[scene.Scene]: ...
def train_cameras() -> Optional[CameraDataset]: ...
def val_cameras() -> Optional[CameraDataset]: ...
def list_scene() -> None: ...
def run(path: str) -> None: ...
def mat4(rows: Sequence[Sequence[float]]) -> Tensor: ...
def help() -> None: ...


# Hook decorators
HookCallback = Callable[[Dict[str, Any]], None]

def on_training_start(callback: HookCallback) -> HookCallback: ...
def on_iteration_start(callback: HookCallback) -> HookCallback: ...
def on_post_step(callback: HookCallback) -> HookCallback: ...
def on_pre_optimizer_step(callback: HookCallback) -> HookCallback: ...
def on_training_end(callback: HookCallback) -> HookCallback: ...


# Animation
FrameCallback = Callable[[float], None]

def on_frame(callback: FrameCallback) -> None: ...
def stop_animation() -> None: ...


# I/O module
ProgressCallback = Callable[[float, str], None]
ExportProgressCallback = Callable[[float, str], bool]


class io:
    """File I/O operations."""

    class LoadResult:
        """Result from loading a file or dataset."""

        @property
        def splat_data(self) -> Optional[scene.SplatData]:
            """Get loaded splat data (None if scene/dataset)."""
            ...
        @property
        def scene_center(self) -> Tensor:
            """Scene center tensor."""
            ...
        @property
        def loader_used(self) -> str:
            """Name of loader that was used."""
            ...
        @property
        def load_time_ms(self) -> int:
            """Load time in milliseconds."""
            ...
        @property
        def warnings(self) -> List[str]:
            """Warnings from loading."""
            ...
        @property
        def is_dataset(self) -> bool:
            """True if loaded a dataset vs single file."""
            ...

    @staticmethod
    def load(
        path: str,
        format: Optional[str] = None,
        resize_factor: Optional[int] = None,
        max_width: Optional[int] = None,
        images_folder: Optional[str] = None,
        progress: Optional[ProgressCallback] = None,
    ) -> "io.LoadResult":
        """Load a file or dataset.

        Args:
            path: Path to file (.ply, .spz, .splat) or dataset directory
            format: Optional format hint (auto-detected if not specified)
            resize_factor: Downscale images by this factor (datasets only)
            max_width: Maximum image width (datasets only)
            images_folder: Name of images folder in dataset (default: "images")
            progress: Optional callback(progress: float, message: str)

        Returns:
            LoadResult with splat_data or scene data
        """
        ...

    @staticmethod
    def save_ply(
        data: scene.SplatData,
        path: str,
        binary: bool = True,
        progress: Optional[ExportProgressCallback] = None,
    ) -> None:
        """Save splat data to PLY file.

        Args:
            data: SplatData to save
            path: Output file path
            binary: Use binary format (default: True, faster and smaller)
            progress: Optional callback(progress: float, stage: str) -> bool
        """
        ...

    @staticmethod
    def save_sog(
        data: scene.SplatData,
        path: str,
        kmeans_iterations: int = 10,
        use_gpu: bool = True,
        progress: Optional[ExportProgressCallback] = None,
    ) -> None:
        """Save splat data to SOG (SuperSplat) format.

        Args:
            data: SplatData to save
            path: Output file path
            kmeans_iterations: K-means iterations for color quantization
            use_gpu: Use GPU for compression
            progress: Optional callback(progress: float, stage: str) -> bool
        """
        ...

    @staticmethod
    def save_spz(data: scene.SplatData, path: str) -> None:
        """Save splat data to SPZ (Niantic compressed) format.

        Args:
            data: SplatData to save
            path: Output file path
        """
        ...

    @staticmethod
    def export_html(
        data: scene.SplatData,
        path: str,
        kmeans_iterations: int = 10,
        progress: Optional[ProgressCallback] = None,
    ) -> None:
        """Export splat data as standalone HTML viewer.

        Args:
            data: SplatData to export
            path: Output HTML file path
            kmeans_iterations: K-means iterations for compression
            progress: Optional callback(progress: float, stage: str)
        """
        ...

    @staticmethod
    def is_dataset_path(path: str) -> bool:
        """Check if path contains a dataset vs single file."""
        ...

    @staticmethod
    def get_supported_formats() -> List[str]:
        """Get list of supported file formats."""
        ...

    @staticmethod
    def get_supported_extensions() -> List[str]:
        """Get list of supported file extensions."""
        ...
